# 带余除法

"""
a = b*q + r, 0 <= r < |b|, b != 0

"""

# 余数 --> 也称非负最小余数

"""
看上面
< a >b = r

"""

# 因数、倍数

"""
b|a --> b 整除 a --> a是b的倍数

"""

### 整除的性质

"""
1、如果b|a, c|b, 则c|a
2、如果c|a, c|b, 则c|(xa+-yb)
3、如果b|a, a|b, 则a = +-b
4、设m!=0, b|a, 则bm|am

"""

# 辗转相除法
"""
这个可以求最大公因数
-->
a = b*q1 + r1
b = r1*q2 + r2
r1 = r2*q3 + r3
-->直到rn == 0 此时qn == (a, b)

代码见gcd.cpp or gcd.py
"""

# 互素、互质概念

"""
如果(a, b) == 1 则说a, b 互质 --> 这个(a, b)是a和b的最大公因数的符号表示
"""

# 引出辗转相除法的依据

"""
a = bq + c

有一个定理:
    (a, b) = (b, c)
"""

# 最大公因数的构造

"""
对任意不全为0的整数a、b, 存在整数u、v, 使得au + bv == gcd(a, b)

怎么做:
    思考从辗转相除法得到的结果:
        回代整个过程即可
        原式子:
            a = bq + r
            回代得到
            a = b*q + y, --> y与gcd(a, b)有关
    
    代码见exgcd.cpp --> 扩展欧几里得算法
    思考代码怎么写:
    四个过程量(a, b, x1, y1)
    最终态 b == 0 此时a = gcd()
    a = b*x1 + y1
    b = a%bx2 + y2
    回代的时候:
    第一层: a * x1 + b * y1 = gcd(a, b)
    第二层: b * x2 + a%b * y2 = gcd(a, b)
    --> b * x2 + (a - (a / b) * b)y2 = gcd(a, b)
    --> b*x2 + a*y2 - (a/b)*b*y2 = gcd(a, b)
    --> a*y2 + b(x2 - (a/b)y2) = gcd(a, b)
    --> x1 = y2
    --> y1 = x2 - (a/b)*y2

"""

# 最小公倍数
"""
[a, b] = |a*b| / (a, b)
"""