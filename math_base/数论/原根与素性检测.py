# 首先是模数的阶

"""
定义:
    设m>0, (a, m) = 1, 使得a^l === 1(mod m) 成立的最小正整数l为a的对模数m的阶, 记为ord(下标为m)(a), 有时在模数m
    不变的时候, 也简记为ord(a)

性质:
    1、如果a === a'(mod m), 则ord(a) = ord(a')
    2、a^n === 1(mod m)的充要条件是ord(a) | n, 从而ord(a) | Oula(m)
    3、ord(a) = l, 则1, a, a^2, a^3, ..., a^(l-1)对模数m两两不同余
    4、ord(a) = l, 则有Oula(l)个数 使得ord(a^那么大) = l成立
    -->定理: ord(a) = l, ord(a^辣么大) = l' --> l' = l / (那么大, l)

"""

# 原根

"""
设整数m>0, (g, m) = 1, 如果ord(g) = Oula(m), 则称g为模数m的一个原根

定理:
    设m>0, (g, m) = 1, 则g为模数m的一个原根的充要条件是g, g^2, g^3, ..., g^Oula(m)为模数m的一组既约剩余系
-->很难证明, 但是可以想象

定理:
    设p是一个奇素数, 则模p有一个原根

定理:
    整数m有原根的充要条件是:
        m = 2, 4, p^a, 2*p^a(a >= 1, p是奇素数)
    
"""

# 阶的计算方法

"""
    方法一:暴力解 遍历找1 见exp.py
    方法二:化大为小法
        讲m进行因式分解, 获得素数乘积, 记ord(下标pi ^ li)(a) = fi(i = 1, 2, ..., s)
        ord(a) = f, 则f = [f1, f2, f3, ..., fs]
    方法三:公式法
        设p是一个素数, a ̸= ±1, (a, p) = 1, ord(下标p^j)(a) = fj, 则fj+1 = fj 或 fj+1 = p*fj
        这个太复杂了 要对应着看 估计不考
        看图片吧, func_3.png

    来一个例题, 见jie.py
"""


# 原根的计算方法

"""
定理:
    设奇素数p满足下面标准:
    素因子分解p-1 = ∏︀pi^ai, 2 = p0<p1<p2<...<ps。又设整数a满足如下条件(a, p) = 1, a ^ (p-1/pi) != 1(mod p), i
    = 0, 1, ..., s, 则a为p的原根

具体计算
    例: 求素数p = 47的一个原根
    对p又标准素因子分解: 47-1 = 46 = 2 * 23
    取整数a = 2, (2, 47) = 1, 2^23 = 1(mod 47), 失败
    a = 3, (3, 47) = 1, 3^23 = 1(mod 47), 失败
    a = 5, (5, 47) = 1, 5^23 = -1!=1 (mod 47), 5 ^ 2 = 25 != 1(mod 47), 可知a = 5 是素数47的一个原根

    来个yg.py
"""


# Elgamal公钥密码体制

"""
首先选取素数p以及它的原根a
然后随机选取整数d, 2 <= d <= p-2, 计算β = a^d(mod p)
其中p, a, β是公开的加密密钥, d是保密的私钥

加密变换
明文m
随机选一个整数k, 2 <= k <= p-2
密文为(c1, c2) -->这是个元组

其中c1 = a^k(mod p)
c2 = m * β^k(mod p)

解密:
    m = c2*(c1^d - 1) --> m*β^k * (a^(k+d))^-1 
    --> m
"""