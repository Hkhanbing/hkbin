# encoding = 'uft-8'

# introduce of waibu sort

"""
问题: 文档的记录很多, 信息量庞大, 无法将整个文档复制内存中进行排序

解决方法: 需要将待排序的记录存储在外存上，排序时再把数据一部分一部分的调入内存进行排序，
在排序过程中需要多次进行内存和外存之间的交换。这种排序方法就称为外部排序

主要考虑: 访问磁盘的次数, 即I/O次数
"""

# 外部排序常用 归并排序法

"""
思路: 将内存区域划分为三个区块, 第一个区块和第二个区块为输入缓冲区, 第三个区块为输出缓冲区
对第一个区块和第二个区块进行内部merge_sort, 当第三个区块装满的时候写入数据

"""


"""
当然你要考虑优化: I/O次数, 因为每次都是二路归并, I/O次数偏多, 可以考虑多路归并

假设有m段初始段
计算一下数据, 二路归并, 归并的趟数是log2(m)
k路归并, 归并的趟数是logk(m)
k越大, 归并趟数越少
初始段m越少, 归并趟数越少


当然多路归并有缺点: 多路归并可以减少归并趟数, 但可能增加比较次数
这样子的话会增加CPU负担, 最终可能导致cpu运行的时间大于内部排序时间
为此应该想一个比较次数与k无关的数据结构


所以K路平衡归并与败者树就来了
计算一下
    初始建树: O(k-1)次比较
    而在这之后, 每次更新: O(logk)
    假设总共有n个数据, 则一趟的复杂度为O(k-1) + O((n-1) * logk) = O(nlogk)
    总共有logk(m)趟, 所以总复杂度为O(nlogk * logk(m)) = O(nlogm)
    得到结论: K路归并的CPU时间与k无关

"""

# 接下来我们分析第二个限制原因 m个数

"""
目的: m尽量少, 减少I/O次数

所以有了置换-选择排序(生成m最少的初始归并段)
给你一个pics 就可以理解了
即:
全部导进来, 给你手动分归并段, 选择缓冲区中比min大的,更新min 并且放入fileout中,直到选不出min了加个休止符#记录为一段


"""

# 到目前为止, 我们解决了初始归并段数量m问题, 归并趟数k问题, 但还有些bug

"""
由置换-选择排序所得初始归并段的长度可能不等:
    给你个pics 可以理解

所以导出了最佳归并树的概念:
    我需要带权最短路径长度最短: min(WPL)
    是不是想到了哈夫曼树
    就是!
    不过是m叉的哈夫曼树
    不够节点的话补0即可 --> 这个称之为虚段

如何计算虚段个数:
    假设度为0的结点有n0个, 度为k的结点有nk个, 则对严格k叉树来说, 满足n0 = (k-1)nk + 1   -->k叉树, 其边等于节点数-1
    proof: no + nk - 1 = k* nk --> n0 = (k-1)nk + 1
    由此可知nk=(n0-1)/(k-1)

对初始段数m的外部归并来说:
    判断虚段个数: m == 叶子节点个数 即n0
    设虚段个数为x
    有nk = (n0 + x - 1) / (k - 1)
    其中又有nk为整数 所以 (m + x -1)%(k-1) == 0
    
    ans : k - 1 - (m - 1) % (k - 1)
"""