# 6.1

"""

排序的目的：方便查询和处理

排序算法的稳定性：比如说 1 2(1) 2(2) --> 2(1) 2(2) 1 表示它是稳定的


排序的分类：
按照数据存放的设备：
    内部排序：数据对象全部在内存中的排序
    外部排序：数据对象并非全在内存中的排序

按照基本操作：
    基于比较：基本操作——关键字的比较和记录的移动，其最差时间下限已经被证明为Ω(nlogn)。 -->书上学的都是基于比较的排序
    不基于比较：根据组成关键字的的分量及其分布特征，如基数排序。

"""

# 6.2

"""
冒泡排序分析：
代码见bubble_sort.cpp

时间复杂度分析：
最好情况：
    比较次数:n-1
    移动次数:0
    时间复杂度O(n)

最坏情况：
    比较次数:n(n-1)/2
    移动次数:3n(n-1)/2 --> 3是swap

平均情况:O(n^2)


空间复杂度:O(1) --> 没创建新空间
"""

# 6.3 -->重点嗷

"""
快速排序 --> 是对冒泡排序的优化，这个优化是指让原本的相邻互换 变成了 跳跃式的互换 大大降低交换次数

代码见quick_sort.cpp

快速排序时间性能分析：-->重点在于基准的确定
    最好情况：-->均分归并
        时间复杂度为O(nlogn)
        空间复杂度为O(logn) --> 需要借助递归工作栈 -->实际上递归语句的下列没有语句的话 编译器会优化pop掉, 所以实际上是O(1)

    最坏情况: -->划分是1:n-1
        时间复杂度为O(n^2)
        空间复杂度为O(n) -->进行n-1 次递归调用
    
    平均情况:
        时间复杂度:O(nlogn)
        空间复杂度:O(logn)

    它是不稳定排序


    有一个好问题记录一下:
        快速排序在什么情况下最不利于发挥其长处
        -->要排序的数据基本有序的情况下
        # 因为它的优势在于跳跃式的互换

    同时它还是目前平均性能最好的内排序方法

    不可能是第几趟排序结果的题：
        你需要找到快速排序的本质，其本质就是每执行完一趟，就能确定好一个值，这个是就是mid = arr[l+r>>1]
        这样子我们写出正确的序列，再对比拍好位置的个数即可

"""


