# 6.1

"""

排序的目的：方便查询和处理

排序算法的稳定性：比如说 1 2(1) 2(2) --> 2(1) 2(2) 1 表示它是稳定的


排序的分类：
按照数据存放的设备：
    内部排序：数据对象全部在内存中的排序
    外部排序：数据对象并非全在内存中的排序

按照基本操作：
    基于比较：基本操作——关键字的比较和记录的移动，其最差时间下限已经被证明为Ω(nlogn)。 -->书上学的都是基于比较的排序
    不基于比较：根据组成关键字的的分量及其分布特征，如基数排序。

"""

# 6.2

"""
冒泡排序分析：
代码见bubble_sort.cpp

时间复杂度分析：
最好情况：
    比较次数:n-1
    移动次数:0
    时间复杂度O(n)

最坏情况：
    比较次数:n(n-1)/2
    移动次数:3n(n-1)/2 --> 3是swap

平均情况:O(n^2)


空间复杂度:O(1) --> 没创建新空间
"""

# 6.3 -->重点嗷

"""
快速排序 --> 是对冒泡排序的优化，这个优化是指让原本的相邻互换 变成了 跳跃式的互换 大大降低交换次数

代码见quick_sort.cpp

快速排序时间性能分析：-->重点在于基准的确定
    最好情况：-->均分归并
        时间复杂度为O(nlogn)
        空间复杂度为O(logn) --> 需要借助递归工作栈 -->实际上递归语句的下列没有语句的话 编译器会优化pop掉, 所以实际上是O(1)

    最坏情况: -->划分是1:n-1
        时间复杂度为O(n^2)
        空间复杂度为O(n) -->进行n-1 次递归调用
    
    平均情况:
        时间复杂度:O(nlogn)
        空间复杂度:O(logn)

    它是不稳定排序


    有一个好问题记录一下:
        快速排序在什么情况下最不利于发挥其长处
        -->要排序的数据基本有序的情况下
        # 因为它的优势在于跳跃式的互换

    同时它还是目前平均性能最好的内排序方法

    不可能是第几趟排序结果的题：
        你需要找到快速排序的本质，其本质就是每执行完一趟，就能确定好一个值，这个是就是mid = arr[l+r>>1]
        这样子我们写出正确的序列，再对比拍好位置的个数即可

"""

# 6.4
"""
直接选择排序
    代码见select_sort.cpp

性能分析:
    最好情况:
        移动次数:0次
    最坏情况:
        移动次数:3(n-1)次
    比较次数:
        n(n-1)/2
    时间复杂度:
        O(n^2)
    空间复杂度O(1)

    稳定性:不稳定排序
    
"""

# 6.5堆排序 --> 选择插入的优化 #重点

"""
O(1)选择最小值 -->堆 -->减少比较次数 顺便留下比较记忆

代码见heap_sort.cpp


时间复杂度分析:
    时间效率:O(n)建堆 每次输出最小值或者最大值后 需要down堆顶 这个操作是O(h) == O(logn)的
        所以总共时间复杂度为O(nlogn)
    
    空间复杂度:O(1)
    稳定性: 不稳定 -->原因在于弹出元素之后， 堆顶元素会和堆尾部互换，然后down

    堆排序适合情况: 最大化利用堆顶查询O(1)情况
    比如在一亿个数中选出前100个最大的值
"""


# 6.6插入排序 

"""
代码见insert_sort.cpp

时间复杂度分析:
    最好情况下:
        比较次数: n-1
        移动次数: 0
        时间复杂度: O(n)
    
    最坏情况下:
        比较次数: n(n+1)/2
        移动次数: n(n-1)/2
        时间复杂度: O(n^2)
    
改进的插入排序 -->折半的插入排序 -->找寻位置的时候使用二分查找

"""

# 6.7希尔排序 --> 插入排序的优化

"""
本质就是分组插入排序
代码实现见shell_sort.cpp

时间复杂度分析:
    O(n^2) ~ O(nlogn)
    根据科学计算大概是O(n^1.3)-->平均时间复杂度
"""

